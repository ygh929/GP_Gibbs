max(y1)
y1-max(y1)
y1=y1-max(y1)
y1
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    }#
    y1=y1-max(y1)#
    y2=y2-max(y2)#
   	y3=y3-max(y3)#
   	y1=exp(y1)#
   	y2=exp(y2)#
   	y3=exp(y3)#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
trian=get_dens(Dat,metric)
levelplot(yhat~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=T, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
Dat=c(10,4,6)
trian=get_dens(Dat,metric)#
#
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
device.new()
dev.new()
trian=get_dens(Dat,metric)#
#
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
dev.new()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
Dat
metric=function(x,y){#
	return(abs(x-y)^2)#
}
metric=function(x,y){#
	return(abs(x-y)^2)#
}#
#
## Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
#a function to calculate 'likelihood' in 3 different ways#
Dat=c(10,4,6)#
#
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    }#
    y1=y1-max(y1)#
    y2=y2-max(y2)#
   	y3=y3-max(y3)#
   	y1=exp(y1)#
   	y2=exp(y2)#
   	y3=exp(y3)#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}#
#
trian=get_dens(Dat,metric)#
#
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
dev.new()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))
trellis.focus("panel", 1, 1, highlight=FALSE)
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))
grade.trellis()
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
I(1!=2)
I(1!=2)*1
metric=function(x,y){#
	return(1*I(x!=y))#
}
trian=get_dens(Dat,metric)
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
?levelplot
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, #
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, #
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)),default.theme=standard.theme(color=F))
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=tray(0:100/100)#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(0:100/100),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(0:100/100),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(0:100/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(0:100/20),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")))#
         )#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")))#
         col=graey(sqe(100,200,20)))
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=graey(sqe(100,200,20)))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(sqe(100,200,20)))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(seq(100,200,20)))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(seq(100,200,20)/200))#
         )
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(seq(100,200,20)/200)))
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=seq(0,1,0.2),    labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(seq(100,200,20)/200))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=seq(0,1,0.2),    labels=c("0","0.2","0.4","0.6","0.8","1"),col=gray(seq(100,200,20)/200))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         #par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=seq(0,1,0.2),    labels=c("0","0.2","0.4","0.6","0.8","1"),col=gray(seq(100,200,20)/200))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=1)),#
         colorkey=list(at=seq(0,1,0.2),    labels=c("0","0.2","0.4","0.6","0.8","1"),col=gray(seq(100,200,20)/200))#
         )
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=1)),#
         colorkey=list(at=seq(0,1,0.2),    labels=c("0","0.2","0.4","0.6","0.8","1"),col=gray(seq(100,200,20)/200))#
         )
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
y1
min(trian$y1)
min(trian$y2)
min(trian$y3)
require(mixexp)#
#
l1=function(Dat,p){#
	#likelihood function#
	l=matrix(Dat,1,3)%*%as.matrix(log(p),1,3)#
	return(l)#
}#
#
l2=function(Dat,metric,p){#
	#expectation of loss function#
	l=-matrix(Dat,1,3)%*%outer(1:3,1:3,metric)%*%as.matrix(p,1,3)#
	return(l)#
}#
#
l3=function(Dat,metric,p){#
	#original loss function#
	rhat=which.max(p)#
	l=-matrix(Dat,1,3)%*%outer(1:3,rhat,metric)#
	return(l)#
}#
#
metric=function(x,y){#
	return((x-y)^2)#
}#
#
## Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
#a function to calculate 'likelihood' in 3 different ways#
Dat=c(10,4,6)#
#
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    }#
    y1=y1-max(y1)#
    y2=y2-max(y2)#
   	y3=y3-max(y3)#
   	y1=exp(y1)#
   	y2=exp(y2)#
   	y3=exp(y3)#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
trian=get_dens(Dat,metric)
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.,label="p3",pos=1)#
trellis.unfocus()
trian=get_dens(Dat,metric)#
#
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,0,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,0,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,0,label="p3",pos=1)#
trellis.unfocus()
vc=6#
eps=0.01#
512*vc/eps^2*log(256*vc/eps^2)
vc=6#
eps=1#
512*vc/eps^2*log(256*vc/eps^2)
vc=6#
eps=1#
n=512*vc/(eps^2)*log(256*vc/(eps^2))#
n^nc#
e^(n*eps^2)/256
vc=6#
eps=1#
n=512*vc/(eps^2)*log(256*vc/(eps^2))#
n^nc#
exp((n*eps^2)/256)
vc=6#
eps=1#
n=512*vc/(eps^2)*log(256*vc/(eps^2))#
n^vc#
exp((n*eps^2)/256)
x=runif(1e4,3,7)
mean(x^2)
mean(x^2)*3
mean(x)^2+var(x)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$normDat#
ntDat=normbyran(tDat,ranDat)#
sDat=Dat#
#sDat=cubicspl(norDat,1)#
stDat=cubicspl(ntDat,1)#
b=SA_s(sDat,1)#
loss_s(b,stDat)
setwd("/Desktop")
setwd("~/Desktop/ranking/code/GP_Gibbs/")
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$normDat#
ntDat=normbyran(tDat,ranDat)#
sDat=Dat#
#sDat=cubicspl(norDat,1)#
stDat=cubicspl(ntDat,1)#
b=SA_s(sDat,1)#
loss_s(b,stDat)
ran[1,]
ranDat
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ranDat#
ntDat=normbyran(tDat,ranDat)#
sDat=Dat#
#sDat=cubicspl(norDat,1)#
stDat=cubicspl(ntDat,1)#
b=SA_s(sDat,1)#
loss_s(b,stDat)
ranDat
nDat
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
sDat=Dat#
#sDat=cubicspl(norDat,1)#
stDat=cubicspl(ntDat,1)#
b=SA_s(sDat,1)#
loss_s(b,stDat)
kmax=1e5#
	sig=0.5 #initial jump sd#
	tolc=1 #initial tol#
	x=cDat$points#
	pairs=cDat$pairs#
	Sig=getSigma(x,kernel1)#
	n=nrow(x)#
	r=sqrt(n)#
	#initialize#
	fI=rmvnorm(1,rep(0,n),Sig)#
	fI=fI/sqrt(sum(fI^2))*r#
	q=phi*loss_GP(fI,pairs)-dmvnorm(fI,mean=rep(0,n),sigma=Sig,log=TRUE)#
	count=0
#try to minimize q=l-log(p)#
	kmax=1e4#
	sig=0.5 #initial jump sd#
	tolc=1 #initial tol#
	ps=ncol(sDat[[1]])#
	r=sqrt(ps)#
	Sig=diag(ps)#
	#initialize#
	b=rmvnorm(1,rep(0,ps),Sig)#
	b=b/sqrt(sum(b^2))*r#
	q=phi*loss_s(b,sDat)-dmvnorm(b,mean=rep(0,ps),sigma=Sig,log=TRUE)#
	count=0
ps
sDat
sDat[[1]]
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
sDat=norDat#
#sDat=cubicspl(norDat,1)#
stDat=cubicspl(ntDat,1)#
b=SA_s(sDat,1)#
loss_s(b,stDat)
loss_s(b,ntDat)
dim(ntDat[[1]])
dim(b)
length(b)
dim(sDat)
dim(sDat[[1]])
b=result$b
b=b$b
b
loss_s(b,ntDat)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
sDat=norDat#
#sDat=cubicspl(norDat,1)#
stDat=cubicspl(ntDat,1)#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
spl<-function(Dat,c,k){#
	#function to get cubic splines with k knots in each dimension#
	x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
	for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+3))#
			newx=cbind(newx,addx)	#
		}#
	}#
	rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	sDat#
}
spl(nDat,3,1)
x=rbind(Dat$X1,Dat$X2)
x
x=rbind(nDat$X1,nDat$X2)
x
nDat
spl(norDat,3,1)
Dat=norDat
spl<-function(Dat,c,k){#
	#function to get cubic splines with k knots in each dimension#
	x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
	for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
			newx=cbind(newx,addx)	#
		}#
	}#
	rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	sDat#
}
Dat=norDat
spl(norDat,3,1)
stDat=spl(ntDat,3,1)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
sDat=spl(norDat,3,1)#
stDat=aspl(ntDat,3,1)#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
sDat=spl(norDat,3,1)#
stDat=spl(ntDat,3,1)#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
b
dim(stDat[[1]])
length(b)
dim(sDat[[1]])
ranDat
nroDat
norDat
newDat
t=NULL
nrow(t[[1]])
nrow(t[[1]])+1
spl<-function(Dat,c,k,tDat=NULL){#
	#function to get cubic splines with k knots in each dimension#
	x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
		if (!is.null(tDat)){#
		mt=nrow(tDat$1)#
		xt=rbind(tDat$1,tDat$2)#
		x=rbind(x,xt)#
	}#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
	for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
			newx=cbind(newx,addx)	#
		}#
	}#
	rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	output=list(sDat=sDat)#
	if (!is.null(tDat)){#
		stDat$X1=newx[(2*m+1):(2*m+m1)]#
		stDat$X2=newx[(2*m+m1+1):(2*m+2*m1)]#
		output=list(sDat=sDat,stDat=stDat)#
	}#
	output#
}
spl<-function(Dat,c,k,tDat=NULL){#
	#function to get cubic splines with k knots in each dimension#
	x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
		if (!is.null(tDat)){#
		m1=nrow(tDat$X1)#
		xt=rbind(tDat$X1,tDat$X2)#
		x=rbind(x,xt)#
	}#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
	for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
			newx=cbind(newx,addx)	#
		}#
	}#
	rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	output=list(sDat=sDat)#
	if (!is.null(tDat)){#
		stDat$X1=newx[(2*m+1):(2*m+m1)]#
		stDat$X2=newx[(2*m+m1+1):(2*m+2*m1)]#
		output=list(sDat=sDat,stDat=stDat)#
	}#
	output#
}
spl(nDat,3,1)
spl(norDat,3,1)
spl(norDat,3,1,ntDat)
spl<-function(Dat,c,k,tDat=NULL){#
	#function to get cubic splines with k knots in each dimension#
	x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
		if (!is.null(tDat)){#
		m1=nrow(tDat$X1)#
		xt=rbind(tDat$X1,tDat$X2)#
		x=rbind(x,xt)#
		newx=as.data.frame(matrix(NA,nrow(x)+m1,0))#
	}#
	for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
			newx=cbind(newx,addx)	#
		}#
	}#
	rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	output=list(sDat=sDat)#
	if (!is.null(tDat)){#
		stDat$X1=newx[(2*m+1):(2*m+m1)]#
		stDat$X2=newx[(2*m+m1+1):(2*m+2*m1)]#
		output=list(sDat=sDat,stDat=stDat)#
	}#
	output#
}
spl(norDat,3,1,ntDat)
Dat=norDat
c=3
k=1
tDat=ntDat
x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
		if (!is.null(tDat)){#
		m1=nrow(tDat$X1)#
		xt=rbind(tDat$X1,tDat$X2)#
		x=rbind(x,xt)#
		newx=as.data.frame(matrix(NA,nrow(x)+m1,0))#
	}
for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
			newx=cbind(newx,addx)	#
		}#
	}
j
x[,1]
tempx=x[,j]
xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)
addx=matrix(NA,nrow(x),k+c)
addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')
addx[,(c+1):(c+k)]=(h*(h>0))^c
colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))
newx=cbind(newx,addx)
newx=as.data.frame(matrix(NA,nrow(x),0))#
		if (!is.null(tDat)){#
		m1=nrow(tDat$X1)#
		xt=rbind(tDat$X1,tDat$X2)#
		x=rbind(x,xt)#
		newx=as.data.frame(matrix(NA,nrow(x),0))#
	}
for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
			newx=cbind(newx,addx)	#
		}#
	}
spl<-function(Dat,c,k,tDat=NULL){#
	#function to get cubic splines with k knots in each dimension#
	x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
		if (!is.null(tDat)){#
		m1=nrow(tDat$X1)#
		xt=rbind(tDat$X1,tDat$X2)#
		x=rbind(x,xt)#
		newx=as.data.frame(matrix(NA,nrow(x),0))#
	}#
	for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
			newx=cbind(newx,addx)	#
		}#
	}#
	rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	output=list(sDat=sDat)#
	if (!is.null(tDat)){#
		stDat$X1=newx[(2*m+1):(2*m+m1)]#
		stDat$X2=newx[(2*m+m1+1):(2*m+2*m1)]#
		output=list(sDat=sDat,stDat=stDat)#
	}#
	output#
}
spl(norDat,3,1,ntDat)
Dat=nroDat
tDat=ntDat
x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
	newx=as.data.frame(matrix(NA,nrow(x),0))
m1=nrow(tDat$X1)#
		xt=rbind(tDat$X1,tDat$X2)#
		x=rbind(x,xt)
dim(x)
newx=as.data.frame(matrix(NA,nrow(x),0))
for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
			newx=cbind(newx,addx)	#
		}#
	}
rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	output=list(sDat=sDat)
stDat$X1=newx[(2*m+1):(2*m+m1)]
spl<-function(Dat,c,k,tDat=NULL){#
	#function to get cubic splines with k knots in each dimension#
	x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
	if (!is.null(tDat)){#
		m1=nrow(tDat$X1)#
		xt=rbind(tDat$X1,tDat$X2)#
		x=rbind(x,xt)#
		newx=as.data.frame(matrix(NA,nrow(x),0))#
	}#
	for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
			addx=matrix(NA,nrow(x),k+c)#
			addx[,1:c]=outer(tempx,1:c,'^')#
			h=outer(tempx,xi,'-')#
			addx[,(c+1):(c+k)]=(h*(h>0))^c#
			colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
			newx=cbind(newx,addx)	#
		}#
	}#
	rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	output=list(sDat=sDat)#
	if (!is.null(tDat)){#
		stDat$X1=newx[(2*m+1):(2*m+m1),]#
		stDat$X2=newx[(2*m+m1+1):(2*m+2*m1),]#
		output=list(sDat=sDat,stDat=stDat)#
	}#
	output#
}
spl(norDat,3,1,ntDat)
sDat=SDat$sDat#
stDat=SDat$stDat
SDat=spl(norDat,3,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
SDat=spl(norDat,3,0,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat
spl<-function(Dat,c,k,tDat=NULL){#
	#function to get cubic splines with k knots in each dimension#
	x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
	if (!is.null(tDat)){#
		m1=nrow(tDat$X1)#
		xt=rbind(tDat$X1,tDat$X2)#
		x=rbind(x,xt)#
		newx=as.data.frame(matrix(NA,nrow(x),0))#
	}#
	for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			if (k>0){#
				xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
				addx=matrix(NA,nrow(x),k+c)#
				addx[,1:c]=outer(tempx,1:c,'^')#
				h=outer(tempx,xi,'-')#
				addx[,(c+1):(c+k)]=(h*(h>0))^c#
				colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
				newx=cbind(newx,addx)	#
			}else{#
				addx=matrix(NA,nrow(x),k+c)#
				addx[,1:c]=outer(tempx,1:c,'^')#
		}#
	}#
	rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	output=list(sDat=sDat)#
	if (!is.null(tDat)){#
		stDat$X1=newx[(2*m+1):(2*m+m1),]#
		stDat$X2=newx[(2*m+m1+1):(2*m+2*m1),]#
		output=list(sDat=sDat,stDat=stDat)#
	}#
	output#
}
SDat=spl(norDat,3,0,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat
spl<-function(Dat,c,k,tDat=NULL){#
	#function to get cubic splines with k knots in each dimension#
	x=rbind(Dat$X1,Dat$X2)#
	m=nrow(Dat$X1)#
	newx=as.data.frame(matrix(NA,nrow(x),0))#
	if (!is.null(tDat)){#
		m1=nrow(tDat$X1)#
		xt=rbind(tDat$X1,tDat$X2)#
		x=rbind(x,xt)#
		newx=as.data.frame(matrix(NA,nrow(x),0))#
	}#
	for (j in 1:ncol(x)){#
		tempx=x[,j]#
		if (length(unique(tempx))<=2){#
			names(tempx)=colnames(x)[j]#
			newx=cbind(newx,tempx)#
		}else{#
			if (k>0){#
				xi=min(tempx)+(range(tempx)[2]-range(tempx)[1])*(1:k)/(k+1)#
				addx=matrix(NA,nrow(x),k+c)#
				addx[,1:c]=outer(tempx,1:c,'^')#
				h=outer(tempx,xi,'-')#
				addx[,(c+1):(c+k)]=(h*(h>0))^c#
				colnames(addx)=sprintf("%s%i",colnames(x)[j],1:(c+k))#
				newx=cbind(newx,addx)	#
			}else{#
				addx=matrix(NA,nrow(x),k+c)#
				addx[,1:c]=outer(tempx,1:c,'^')#
				}#
		}#
	}#
	rownames(newx)=rownames(x)#
	sDat=list(X1=NULL,X2=NULL)#
	sDat$X1=newx[1:m,]#
	sDat$X2=newx[(m+1):(2*m),]#
	output=list(sDat=sDat)#
	if (!is.null(tDat)){#
		stDat$X1=newx[(2*m+1):(2*m+m1),]#
		stDat$X2=newx[(2*m+m1+1):(2*m+2*m1),]#
		output=list(sDat=sDat,stDat=stDat)#
	}#
	output#
}
SDat=spl(norDat,3,0,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,3,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,2,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,2,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=100 #number of pairs in testing data#
N=100# number of samples in posterior sampling#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,2,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=1000 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,2,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=1000 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,2,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=2000 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,2,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)/tm#
loss_s(b,sDat)/m
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=2000 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,2,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)/tm#
loss_s(b,sDat)/m
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=2000 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,2,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)/tm#
loss_s(b,sDat)/m
tm=20000 #number of pairs in testing data
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=100 #number of pairs in training data#
tm=20000 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
SDat=spl(norDat,2,1,ntDat)#
sDat=SDat$sDat#
stDat=SDat$stDat#
result=SA_s(sDat,1)#
b=result$b#
loss_s(b,stDat)/tm#
loss_s(b,sDat)/m
rm(list=ls())
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
#
Pow=1:3#
K=0:2#
i=1#
j=1#
E1=matrix(NA,nrow=length(Pow),ncol=length(K))#
E2=E1#
#
for (pow in Pow){#
	for (k in K){#
		SDat=spl(norDat,pow,k,ntDat)#
		sDat=SDat$sDat#
		stDat=SDat$stDat#
		result=SA_s(sDat,1)#
		b=result$b#
		e1=loss_s(b,stDat)/tm#
		e2=loss_s(b,sDat)/m#
		msg1=sprintf("power: %f, nknots: %f",pow,k)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f",e1,e2)#
		print(msg2)#
		E1[i,j]=e1#
		E2[i,j]=e2#
		j=j+1#
	}#
	i=i+1#
}
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
#
Pow=1:3#
K=0:2#
i=1#
j=1#
E1=matrix(NA,nrow=length(Pow),ncol=length(K))#
E2=E1#
#
for (pow in Pow){#
	for (k in K){#
		SDat=spl(norDat,pow,k,ntDat)#
		sDat=SDat$sDat#
		stDat=SDat$stDat#
		result=SA_s(sDat,1)#
		b=result$b#
		e1=loss_s(b,stDat)/tm#
		e2=loss_s(b,sDat)/m#
		msg1=sprintf("power: %f, nknots: %f",pow,k)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f",e1,e2)#
		print(msg2)#
		E1[i,j]=e1#
		E2[i,j]=e2#
		j=j+1#
	}#
	i=i+1#
}
i
j
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
#
Pow=1:3#
K=0:2#
i=1#
j=1#
E1=matrix(NA,nrow=length(Pow),ncol=length(K))#
E2=E1#
#
for (pow in Pow){#
	j=1#
	for (k in K){#
		SDat=spl(norDat,pow,k,ntDat)#
		sDat=SDat$sDat#
		stDat=SDat$stDat#
		result=SA_s(sDat,1)#
		b=result$b#
		e1=loss_s(b,stDat)/tm#
		e2=loss_s(b,sDat)/m#
		msg1=sprintf("power: %f, nknots: %f",pow,k)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f",e1,e2)#
		print(msg2)#
		E1[i,j]=e1#
		E2[i,j]=e2#
		j=j+1#
	}#
	i=i+1#
}
pow=2
k=1
SDat=spl(norDat,pow,k,ntDat)#
		sDat=SDat$sDat#
		stDat=SDat$stDat#
		result=SA_s(sDat,1)#
		b=result$b#
		e1=loss_s(b,stDat)/tm#
		e2=loss_s(b,sDat)/m#
		msg1=sprintf("power: %f, nknots: %f",pow,k)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f",e1,e2)#
		print(msg2)#
		E1[i,j]=e1#
		E2[i,j]=e2
pow=1
k=0
SDat=spl(norDat,pow,k,ntDat)#
		sDat=SDat$sDat#
		stDat=SDat$stDat#
		result=SA_s(sDat,1)#
		b=result$b#
		e1=loss_s(b,stDat)/tm#
		e2=loss_s(b,sDat)/m#
		msg1=sprintf("power: %f, nknots: %f",pow,k)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f",e1,e2)#
		print(msg2)
b
sDat
ntDat
SDat=spl(norDat,pow,k,ntDat)#
		sDat=SDat$sDat#
		stDat=SDat$stDat#
		result=SA_s(sDat,1)#
		b=result$b#
		e1=loss_s(b,stDat)/tm#
		e2=loss_s(b,sDat)/m#
		msg1=sprintf("power: %f, nknots: %f",pow,k)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f",e1,e2)#
		print(msg2)
b
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#sieve approach#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat=normbyran(tDat,ranDat)#
#
Pow=1:3#
K=0:0#
i=1#
j=1#
E1=matrix(NA,nrow=length(Pow),ncol=length(K))#
E2=E1#
#
for (pow in Pow){#
	j=1#
	for (k in K){#
		SDat=spl(norDat,pow,k,ntDat)#
		sDat=SDat$sDat#
		stDat=SDat$stDat#
		result=SA_s(sDat,1)#
		b=result$b#
		e1=loss_s(b,stDat)/tm#
		e2=loss_s(b,sDat)/m#
		msg1=sprintf("power: %f, nknots: %f",pow,k)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f",e1,e2)#
		print(msg2)#
		E1[i,j]=e1#
		E2[i,j]=e2#
		j=j+1#
	}#
	i=i+1#
}
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#
#first norm to [-1,1]#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat0=normbyran(tDat,ranDat)#
#
cDat=convertDat(norDat)#
#estimate fI#
Kappa=1:3#
Phi=(1:3)*0.2#
E1=matrix(NA,length(Kappa),length(Phi))#
E2=E1#
E3=E1#
i=1#
for (kap in Kappa){#
	kernel1<-function(x1,x2,kappa=kap){#
		#kernal function to generate Sigma#
		k=sum((x1-x2)^2)#
		K=exp(-kappa*k/2)#
		K#
	}#
	j=1#
	for (phi in Phi){#
		result=SA_GP(cDat,phi)#
		fI=result$fI#
		Sig=result$Sig#
		#predict for test set and calculate error rate#
		err=rep(NA,tm)#
		x=cDat$points#
		#normalize test data first#
		ntDat=ntDat0		#
		for (i in 1:tm){#
			xt=rbind(ntDat$X1[i,],ntDat$X2[i,])#
			coSig=getcov(xt,x,kernel1)#
			Y=pre_GP(coSig,Sig,fI)#
			err[i]=I(Y[1]<Y[2])#
		}#
		e1=mean(err)#
		err=rep(NA,m)#
		ntDat=norDat#
		for (i in 1:m){#
			xt=rbind(ntDat$X1[i,],ntDat$X2[i,])#
			coSig=getcov(xt,x,kernel1)#
			Y=pre_GP(coSig,Sig,fI)#
			err[i]=I(Y[1]<Y[2])#
		}#
		e2=mean(err)#
		e3=loss_GP(fI,cDat$pairs)/m#
		msg1=sprintf("kappa: %f, phi: %f",kap,phi)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f, loss at fI: %f",e1,e2,e3)#
		print(msg2)#
		E1[i,j]=e1#
		E2[i,j]=e2#
		E3[i,j]=e3#
		j=j+1#
	}#
	i=i+1#
}
i
j
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#
#first norm to [-1,1]#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat0=normbyran(tDat,ranDat)#
#
cDat=convertDat(norDat)#
#estimate fI#
Kappa=1:3#
Phi=(1:3)*0.2#
E1=matrix(NA,length(Kappa),length(Phi))#
E2=E1#
E3=E1#
l=1#
for (kap in Kappa){#
	kernel1<-function(x1,x2,kappa=kap){#
		#kernal function to generate Sigma#
		k=sum((x1-x2)^2)#
		K=exp(-kappa*k/2)#
		K#
	}#
	j=1#
	for (phi in Phi){#
		result=SA_GP(cDat,phi)#
		fI=result$fI#
		Sig=result$Sig#
		#predict for test set and calculate error rate#
		err=rep(NA,tm)#
		x=cDat$points#
		#normalize test data first#
		ntDat=ntDat0		#
		for (i in 1:tm){#
			xt=rbind(ntDat$X1[i,],ntDat$X2[i,])#
			coSig=getcov(xt,x,kernel1)#
			Y=pre_GP(coSig,Sig,fI)#
			err[i]=I(Y[1]<Y[2])#
		}#
		e1=mean(err)#
		err=rep(NA,m)#
		ntDat=norDat#
		for (i in 1:m){#
			xt=rbind(ntDat$X1[i,],ntDat$X2[i,])#
			coSig=getcov(xt,x,kernel1)#
			Y=pre_GP(coSig,Sig,fI)#
			err[i]=I(Y[1]<Y[2])#
		}#
		e2=mean(err)#
		e3=loss_GP(fI,cDat$pairs)/m#
		msg1=sprintf("kappa: %f, phi: %f",kap,phi)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f, loss at fI: %f",e1,e2,e3)#
		print(msg2)#
		E1[l,j]=e1#
		E2[l,j]=e2#
		E3[l,j]=e3#
		j=j+1#
	}#
	l=l+1#
}
E1
save(E1,E2,E3,'temp.Rdata')
save(E1,E2,E3,"temp.Rdata")
save(E1,E2,E3,file="temp.Rdata")
geterr_GP<-fucntion(ntDat,x,Sig,fI){#
	err=rep(NA,tm)#
	tm=nrow(ntDat[[1]])#
	for (i in 1:tm){#
			xt=rbind(ntDat$X1[i,],ntDat$X2[i,])#
			coSig=getcov(xt,x,kernel1)#
			Y=pre_GP(coSig,Sig,fI)#
			err[i]=I(Y[1]<Y[2])#
		}#
	e=mean(err)#
	e#
}
geterr_GP*ntDat,x,Sig,fI_
geterr_GP*ntDat,x,Sig,fI)
geterr_GP(ntDat,x,Sig,fI)
geterr_GP<-fucntion(ntDat,x,Sig,fI){#
	err=rep(NA,tm)#
	tm=nrow(ntDat[[1]])#
	for (i in 1:tm){#
			xt=rbind(ntDat$X1[i,],ntDat$X2[i,])#
			coSig=getcov(xt,x,kernel1)#
			Y=pre_GP(coSig,Sig,fI)#
			err[i]=I(Y[1]<Y[2])#
		}#
	e=mean(err)#
	e#
}
geterr_GP<-function(ntDat,x,Sig,fI){#
	err=rep(NA,tm)#
	tm=nrow(ntDat[[1]])#
	for (i in 1:tm){#
			xt=rbind(ntDat$X1[i,],ntDat$X2[i,])#
			coSig=getcov(xt,x,kernel1)#
			Y=pre_GP(coSig,Sig,fI)#
			err[i]=I(Y[1]<Y[2])#
		}#
	e=mean(err)#
	e#
}
geterr_GP(ntDat,x,Sig,fI)
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#
#first norm to [-1,1]#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat0=normbyran(tDat,ranDat)#
#
cDat=convertDat(norDat)#
#estimate fI#
Kappa=1:10#
Phi=(1:10)*0.2#
E1=matrix(NA,length(Kappa),length(Phi))#
E2=E1#
E3=E1#
l=1#
for (kap in Kappa){#
	kernel1<-function(x1,x2,kappa=kap){#
		#kernal function to generate Sigma#
		k=sum((x1-x2)^2)#
		K=exp(-kappa*k/2)#
		K#
	}#
	j=1#
	for (phi in Phi){#
		result=SA_GP(cDat,phi)#
		fI=result$fI#
		Sig=result$Sig#
		#predict for test set and calculate error rate#
		x=cDat$points#
		e1=geterr_GP(ntDat0,x,Sig,fI)#
		e2=geterr_GP(norDat,x,Sig,fI)#
		e3=loss_GP(fI,cDat$pairs)/m#
		msg1=sprintf("kappa: %f, phi: %f",kap,phi)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f, loss at fI: %f",e1,e2,e3)#
		print(msg2)#
		E1[l,j]=e1#
		E2[l,j]=e2#
		E3[l,j]=e3#
		j=j+1#
	}#
	l=l+1#
}#
save(E1,E2,E3,file="errors_GP.Rdata")
e2=geterr_GP(norDat,x,Sig,fI)
e2
ntDat=norDat
err=rep(NA,tm)#
	tm=nrow(ntDat[[1]])
tm
for (i in 1:tm){#
			xt=rbind(ntDat$X1[i,],ntDat$X2[i,])#
			coSig=getcov(xt,x,kernel1)#
			Y=pre_GP(coSig,Sig,fI)#
			err[i]=I(Y[1]<Y[2])#
		}
err
tm
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#
#first norm to [-1,1]#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat0=normbyran(tDat,ranDat)#
#
cDat=convertDat(norDat)#
#estimate fI#
Kappa=1:10#
Phi=(1:10)*0.2#
E1=matrix(NA,length(Kappa),length(Phi))#
E2=E1#
E3=E1#
l=1#
for (kap in Kappa){#
	kernel1<-function(x1,x2,kappa=kap){#
		#kernal function to generate Sigma#
		k=sum((x1-x2)^2)#
		K=exp(-kappa*k/2)#
		K#
	}#
	j=1#
	for (phi in Phi){#
		result=SA_GP(cDat,phi)#
		fI=result$fI#
		Sig=result$Sig#
		#predict for test set and calculate error rate#
		x=cDat$points#
		e1=geterr_GP(ntDat0,x,Sig,fI)#
		e2=geterr_GP(norDat,x,Sig,fI)#
		e3=loss_GP(fI,cDat$pairs)/m#
		msg1=sprintf("kappa: %f, phi: %f",kap,phi)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f, loss at fI: %f",e1,e2,e3)#
		print(msg2)#
		E1[l,j]=e1#
		E2[l,j]=e2#
		E3[l,j]=e3#
		j=j+1#
	}#
	l=l+1#
}#
save(E1,E2,E3,file="errors_GP.Rdata")
rm(list=ls())
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#
#first norm to [-1,1]#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat0=normbyran(tDat,ranDat)#
#
cDat=convertDat(norDat)#
#estimate fI#
Kappa=1:10#
Phi=(1:10)*0.2#
E1=matrix(NA,length(Kappa),length(Phi))#
E2=E1#
E3=E1#
l=1#
for (kap in Kappa){#
	kernel1<-function(x1,x2,kappa=kap){#
		#kernal function to generate Sigma#
		k=sum((x1-x2)^2)#
		K=exp(-kappa*k/2)#
		K#
	}#
	j=1#
	for (phi in Phi){#
		result=SA_GP(cDat,phi)#
		fI=result$fI#
		Sig=result$Sig#
		#predict for test set and calculate error rate#
		x=cDat$points#
		e1=geterr_GP(ntDat0,x,Sig,fI)#
		e2=geterr_GP(norDat,x,Sig,fI)#
		e3=loss_GP(fI,cDat$pairs)/m#
		msg1=sprintf("kappa: %f, phi: %f",kap,phi)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f, loss at fI: %f",e1,e2,e3)#
		print(msg2)#
		E1[l,j]=e1#
		E2[l,j]=e2#
		E3[l,j]=e3#
		j=j+1#
	}#
	l=l+1#
}#
save(E1,E2,E3,file="errors_GP.Rdata")
Dat=read.table("pyrim.data",sep=",")#
colnames(Dat)=read.table("pyrim.domain",sep=":")$V1#
source("./functions.r")#
nc=ncol(Dat)#
y=Dat[,nc]#
Dat=Dat[,1:(nc-1)]#
m=10 #number of pairs in training data#
tm=20 #number of pairs in testing data#
#
newDat=samplepairs(m,Dat,y)#
tDat=samplepairs(tm,Dat,y)#
#
#first norm to [-1,1]#
nDat=normto1(newDat)#
norDat=nDat$normDat#
ranDat=nDat$ran#
ntDat0=normbyran(tDat,ranDat)#
#
cDat=convertDat(norDat)#
#estimate fI#
Kappa=1:10#
Phi=(1:10)*0.2#
E1=matrix(NA,length(Kappa),length(Phi))#
E2=E1#
E3=E1#
l=1#
for (kap in Kappa){#
	kernel1<-function(x1,x2,kappa=kap){#
		#kernal function to generate Sigma#
		k=sum((x1-x2)^2)#
		K=exp(-kappa*k/2)#
		K#
	}#
	j=1#
	for (phi in Phi){#
		result=SA_GP(cDat,phi)#
		fI=result$fI#
		Sig=result$Sig#
		#predict for test set and calculate error rate#
		x=cDat$points#
		e1=geterr_GP(ntDat0,x,Sig,fI)#
		e2=geterr_GP(norDat,x,Sig,fI)#
		e3=loss_GP(fI,cDat$pairs)/m#
		msg1=sprintf("kappa: %f, phi: %f",kap,phi)#
		print(msg1)#
		msg2=sprintf("testing err: %f, training err: %f, loss at fI: %f",e1,e2,e3)#
		print(msg2)#
		E1[l,j]=e1#
		E2[l,j]=e2#
		E3[l,j]=e3#
		j=j+1#
	}#
	l=l+1#
}#
save(E1,E2,E3,file="errors_GP.Rdata")
