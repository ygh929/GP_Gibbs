for (i in 1:3){#
	dev.new()#
	MixturePlot(Result[,1],Result[,2],Result[,3],Result[,3+i],cols=TRUE,despts=FALSE, x3lab="p3",x2lab="p2",x1lab="p1")#
}
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	p1=seq(0,1,d)#
	outDat=matrix(0,0,6)#
	for (temp1 in p1){#
		p2=seq(0,1-temp1,d)#
		for (temp2 in p2){#
			p=c(temp1,temp2,1-temp1-temp2)#
			y1=l1(Dat,p)#
			y2=l2(Dat,metric,p)#
			y3=l3(Dat,metric,p)#
			newdata=cbind(matrix(p,1,3),y1,y2,y3)#
			outDat=rbind(outDat,newdata)#
		}#
	}#
	#normalize outDat#
	for (j in 4:6){#
		outDat[,j]=outDat[,j]-max(outDat[,j])#
		outDat[,j]=exp(outDat[,j])#
	}#
	return(outDat)#
}#
#
Result=get_dens(Dat,metric)#
#
for (i in 1:3){#
	dev.new()#
	MixturePlot(Result[,1],Result[,2],Result[,3],Result[,3+i],mod=1,cols=TRUE,despts=FALSE, x3lab="p3",x2lab="p2",x1lab="p1")#
}
min(Result)
for (i in 1:3){#
	dev.new()#
	MixturePlot(Result[,1],Result[,2],Result[,3],Result[,3+i],mod=2,cols=TRUE,despts=FALSE, x3lab="p3",x2lab="p2",x1lab="p1")#
}
?MixturePlot
install.packages("klaR")
??klaR
a1 <- a2 <- a3 <- 2 #
#a2 <- .5 #
#a3 <- .5 #
#
x1 <- x2 <- seq(0.01, .99, by=.01)#
#
f <- function(x1, x2){#
#
       term1 <- gamma(a1+a2+a3)/(gamma(a1)*gamma(a2)*gamma(a3))#
       term2 <- x1^(a1-1)*x2^(a2-1)*(1-x1-x2)^(a3-1)#
       term3 <- (x1 + x2 < 1)#
       term1*term2*term3#
       }#
#
z <- outer(x1, x2, f) #
z[z<=0] <- NA#
#
persp(x1, x2, z,#
#
       main = "Dirichlet Distribution",#
       col = "lightblue",#
       theta = 50,#
       phi = 20,#
       r = 50,#
       d = 0.1,#
       expand = 0.5,#
       ltheta = 90,#
       lphi = 180,#
       shade = 0.75,#
       ticktype = "detailed",#
       nticks = 5)
simplex.y  <- function(x) {#
  return( sqrt(0.75) *  x[3] / sum(x) )#
} #
simplex.x  <- function(x) {#
  return( (x[2] + 0.5 * x[3]) / sum(x) )#
}#
#
x  <- data.frame(#
  x1 = c( 0, 0, 1, 0.1, 0.6, 0.2 ),#
  x2 = c( 0, 1, 0, 0.3, 0.2, 0.8 ),#
  x3 = c( 1, 0, 0, 0.6, 0.2, 0.0 )#
)#
#
newDat <- data.frame(x = apply(x,1,simplex.x),#
                y = apply(x,1,simplex.y))#
#
ggplot(newDat,aes(x = x,y = y)) + #
    geom_point()
require(ggplot2)
simplex.y  <- function(x) {#
  return( sqrt(0.75) *  x[3] / sum(x) )#
} #
simplex.x  <- function(x) {#
  return( (x[2] + 0.5 * x[3]) / sum(x) )#
}#
#
x  <- data.frame(#
  x1 = c( 0, 0, 1, 0.1, 0.6, 0.2 ),#
  x2 = c( 0, 1, 0, 0.3, 0.2, 0.8 ),#
  x3 = c( 1, 0, 0, 0.6, 0.2, 0.0 )#
)#
#
newDat <- data.frame(x = apply(x,1,simplex.x),#
                y = apply(x,1,simplex.y))#
#
ggplot(newDat,aes(x = x,y = y)) + #
    geom_point()
paint <- data.frame(mono=c(17.5, 10, 15, 25, 5, 5, 11.25, 5, 18.13, 8.13, 25, 15, 10, 5),#
                    cross=c(32.5, 40, 25, 25, 25, 32.5, 32.5, 40, 28.75, 28.75, 25, 25, 40, 25),#
                    resin=c(50, 50, 60, 50, 70, 62.5, 56.25, 55, 53.13, 63.13, 50, 60, 50, 70),#
                    hardness=c(29, 26, 17, 28, 35, 31, 21, 20, 29, 25, 19, 14, 30, 23))#
#
pseudo <- with(paint, data.frame(mono=(mono-5)/(25-5), resin=(resin-50)/(70-50)))#
pseudo$cross <- with(pseudo, 1-mono-resin)#
pseudo$hardness <- paint$hardness#
#
m1 <- lm(hardness~(mono+cross+resin)^2-mono, data=pseudo)#
#
trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
trian <- subset(trian, (base*sin(pi/3)*2)>high)#
trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
#
new2 <- data.frame(cross=trian$high*2/sqrt(3))#
new2$resin <- trian$base-trian$high/sqrt(3)#
new2$mono <- 1-new2$resin-new2$cross#
#
trian$yhat <- predict(m1, newdata=new2)#
#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
levelplot(yhat~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)),#
          panel=function(..., at, contour=TRUE, labels=NULL){#
            panel.levelplot(..., at=at, contour=contour, #labels=labels,#
                            lty=3, lwd=0.5, col=1)#
          })#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(0, 0, label="mono", pos=2)#
panel.text(1/2, sqrt(3)/2, label="cross", pos=3)#
panel.text(1, 0, label="resin", pos=4)#
trellis.unfocus()
x1<-c(1,0,0,.5,.5,0,.33333,.33333,.33333)#
x2<-c(0,1,0,.5,0,.5,.33333,.33333,.33333)#
x3<-c(0,0,1,0,.5,.5,.33333,.33333,.33333)#
y<-c(73,68,80,77,86,75,92,93,88)#
des<-data.frame(x1,x2,x3,y)#
MixturePlot(des=des,x3lab="Fraction C",x2lab="Fraction B",#
   x1lab="Fraction A",corner.labs=c("C","B","A"),mod=3,n.breaks=5,cols=TRUE)
MixturePlot(Dat[,1],Dat[,2],Dat[,3],Dat[,4],x3lab="Fraction C",x2lab="Fraction B",#
   x1lab="Fraction A",corner.labs=c("C","B","A"),mod=3,n.breaks=5,cols=TRUE)
Dat
MixturePlot(Result[,1],Result[,2],Result[,3],Result[,4],x3lab="Fraction C",x2lab="Fraction B",#
   x1lab="Fraction A",corner.labs=c("C","B","A"),mod=3,n.breaks=5,cols=TRUE)
MixturePlot(Result[,1],Result[,2],Result[,3],Result[,5],x3lab="Fraction C",x2lab="Fraction B",#
   x1lab="Fraction A",corner.labs=c("C","B","A"),mod=3,n.breaks=5,cols=TRUE)
MixturePlot(Result[,1],Result[,2],Result[,3],Result[,5],mod=3,n.breaks=5,cols=TRUE)
MixturePlot(Result[,1],Result[,2],Result[,3],Result[,5],mod=3,cols=TRUE)
MixturePlot(Result[,1],Result[,2],Result[,3],Result[,5],mod=1,cols=TRUE)
MixturePlot(Result[,1],Result[,2],Result[,3],Result[,5],mod=1)
Generate triangular plot.#
## Attach lattice library.#
library(lattice)
Generate triangular area for plotting.#
trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
trian <- subset(trian, (base*sin(pi/3)*2)>high)#
trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)
new <- data.frame(x2=trian$high*2/sqrt(3))#
new$x3 <- trian$base-trian$high/sqrt(3)#
new$x1 <- 1-new$x3-new$x2
?levelplot
Result
x1=Result[,1]
x2=Result[,2]
x3=Result[,3]
xy=Result[,4]
Fit model to data.#
m1 = lm(y ~ -1 + x1 + x2 + x3 + x1*x2 + x1*x3 + x2*x3)#
#
## Combine model effects for F test.#
q = anova(m1)#
mss = sum(q[1:6,2])#
mdof = round(sum(q[1:6,1]),1)#
mmse = mss/mdof#
rss = q[7,2]#
rdof = q[7,1]#
mse = rss/rdof#
#
## Combine and print results.#
residual = c(rdof,rss,mse,NA,NA)#
model = c(mdof,mss,mmse,mmse/mse,df(mmse/mse,mdof,rdof))#
a = data.frame(rbind(model,residual))#
names(a) = c("DOF","Sum-of-Squares","MSE","F Value","Prob > F")#
a#
#
>          DOF Sum-of-Squares         MSE F Value     Prob > F#
> model      6        2878.27 479.7116667 658.141 1.547746e-13#
> residual   9           6.56   0.7288889      NA           NA#
#
## Print summary of model fit.#
summary(m1)#
#
> Call:#
> lm(formula = y ~ -1 + x1 + x2 + x3 + x1 * x2 + x1 * x3 + x2 * #
>     x3)#
>#
> Residuals:#
>    Min     1Q Median     3Q    Max #
>  -0.80  -0.50  -0.30   0.65   1.30 #
>#
> Coefficients:#
>       Estimate Std. Error t value Pr(>|t|)    #
> x1     11.7000     0.6037  19.381 1.20e-08 ***#
> x2      9.4000     0.6037  15.571 8.15e-08 ***#
> x3     16.4000     0.6037  27.166 6.01e-10 ***#
> x1:x2  19.0000     2.6082   7.285 4.64e-05 ***#
> x1:x3  11.4000     2.6082   4.371  0.00180 ** #
> x2:x3  -9.6000     2.6082  -3.681  0.00507 ** #
> ---#
> Signif. codes:  0 �***� 0.001 �**� 0.01 �*� 0.05 �.� 0.1 � � 1 #
>#
> Residual standard error: 0.8537 on 9 degrees of freedom#
> Multiple R-squared: 0.9977,     Adjusted R-squared: 0.9962 #
> F-statistic: 658.1 on 6 and 9 DF,  p-value: 2.271e-11 #
## Generate triangular plot.#
## Attach lattice library.#
library(lattice)#
#
## Generate triangular area for plotting.#
trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
trian <- subset(trian, (base*sin(pi/3)*2)>high)#
trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
#
new <- data.frame(x2=trian$high*2/sqrt(3))#
new$x3 <- trian$base-trian$high/sqrt(3)#
new$x1 <- 1-new$x3-new$x2#
#
## Predict triangular surface based on regression model.#
trian$yhat <- predict(m1, newdata=new)#
#
## Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
## Generate triangular contour plot.#
levelplot(yhat~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
m1
m1 = lm(y ~ -1 + x1 + x2 + x3 + x1*x2 + x1*x3 + x2*x3)
length(x1)
length(x2)
length(x3)
length(x4)
length(y)
y=Result[,4]
length(y)
Fit model to data.#
m1 = lm(y ~ -1 + x1 + x2 + x3 + x1*x2 + x1*x3 + x2*x3)#
#
## Combine model effects for F test.#
q = anova(m1)#
mss = sum(q[1:6,2])#
mdof = round(sum(q[1:6,1]),1)#
mmse = mss/mdof#
rss = q[7,2]#
rdof = q[7,1]#
mse = rss/rdof#
#
## Combine and print results.#
residual = c(rdof,rss,mse,NA,NA)#
model = c(mdof,mss,mmse,mmse/mse,df(mmse/mse,mdof,rdof))#
a = data.frame(rbind(model,residual))#
names(a) = c("DOF","Sum-of-Squares","MSE","F Value","Prob > F")#
a#
#
>          DOF Sum-of-Squares         MSE F Value     Prob > F#
> model      6        2878.27 479.7116667 658.141 1.547746e-13#
> residual   9           6.56   0.7288889      NA           NA#
#
## Print summary of model fit.#
summary(m1)#
#
> Call:#
> lm(formula = y ~ -1 + x1 + x2 + x3 + x1 * x2 + x1 * x3 + x2 * #
>     x3)#
>#
> Residuals:#
>    Min     1Q Median     3Q    Max #
>  -0.80  -0.50  -0.30   0.65   1.30 #
>#
> Coefficients:#
>       Estimate Std. Error t value Pr(>|t|)    #
> x1     11.7000     0.6037  19.381 1.20e-08 ***#
> x2      9.4000     0.6037  15.571 8.15e-08 ***#
> x3     16.4000     0.6037  27.166 6.01e-10 ***#
> x1:x2  19.0000     2.6082   7.285 4.64e-05 ***#
> x1:x3  11.4000     2.6082   4.371  0.00180 ** #
> x2:x3  -9.6000     2.6082  -3.681  0.00507 ** #
> ---#
> Signif. codes:  0 �***� 0.001 �**� 0.01 �*� 0.05 �.� 0.1 � � 1 #
>#
> Residual standard error: 0.8537 on 9 degrees of freedom#
> Multiple R-squared: 0.9977,     Adjusted R-squared: 0.9962 #
> F-statistic: 658.1 on 6 and 9 DF,  p-value: 2.271e-11 #
## Generate triangular plot.#
## Attach lattice library.#
library(lattice)#
#
## Generate triangular area for plotting.#
trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
trian <- subset(trian, (base*sin(pi/3)*2)>high)#
trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
#
new <- data.frame(x2=trian$high*2/sqrt(3))#
new$x3 <- trian$base-trian$high/sqrt(3)#
new$x1 <- 1-new$x3-new$x2#
#
## Predict triangular surface based on regression model.#
trian$yhat <- predict(m1, newdata=new)#
#
## Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
## Generate triangular contour plot.#
levelplot(yhat~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
trian
?expand.grid
trian[1,]
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    }#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
trian=tet_dens(Dat,metric)
trian=get_dens(Dat,metric)
Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
## Generate triangular contour plot.#
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
## Generate triangular contour plot.#
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
## Generate triangular contour plot.#
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
## Generate triangular contour plot.#
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=TRUE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    	y1=y1-max(y1)#
    	y2=y2-max(y2)#
    	y3=y3-max(y3)#
    	y1=exp(y1)#
    	y2=exp(y2)#
    	y3=exp(y3)#
    }#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
get_dens(Dat,metrix)
get_dens(Dat,metric)
trian=get_dens(Dat,metric)
trian$y1[1]
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    	y1=y1-max(y1)#
    	y2=y2-max(y2)#
    	y3=y3-max(y3)#
    	#y1=exp(y1)#
    	y2=exp(y2)#
    	y3=exp(y3)#
    }#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
trian=get_dens(Dat,metric)
trian$y1[1]
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    	#y1=y1-max(y1)#
    	y2=y2-max(y2)#
    	y3=y3-max(y3)#
    	#y1=exp(y1)#
    	y2=exp(y2)#
    	y3=exp(y3)#
    }#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
trian=get_dens(Dat,metric)
trian$y1[1]
exp(-inf)
exp(-Inf)
max(trian$y1)
-Inf+12.9
sum(is.infinite(trian$y1))
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    	y1=y1-max(y1)#
    	y2=y2-max(y2)#
    	y3=y3-max(y3)#
    	#y1=exp(y1)#
    	y2=exp(y2)#
    	y3=exp(y3)#
    }#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
trian=get_dens(Dat,metric)
sum(is.infinite(trian$y1))
y1
trian$y1
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    	#y1=y1-max(y1)#
    	y2=y2-max(y2)#
    	y3=y3-max(y3)#
    	#y1=exp(y1)#
    	y2=exp(y2)#
    	y3=exp(y3)#
    }#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
trian=get_dens(Dat,metric)
trian$y1
y1=trian$y1
max(y1)
y1-max(y1)
y1=y1-max(y1)
y1
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    }#
    y1=y1-max(y1)#
    y2=y2-max(y2)#
   	y3=y3-max(y3)#
   	y1=exp(y1)#
   	y2=exp(y2)#
   	y3=exp(y3)#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
trian=get_dens(Dat,metric)
levelplot(yhat~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=T, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
Dat=c(10,4,6)
trian=get_dens(Dat,metric)#
#
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
device.new()
dev.new()
trian=get_dens(Dat,metric)#
#
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
dev.new()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
Dat
metric=function(x,y){#
	return(abs(x-y)^2)#
}
metric=function(x,y){#
	return(abs(x-y)^2)#
}#
#
## Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
#a function to calculate 'likelihood' in 3 different ways#
Dat=c(10,4,6)#
#
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    }#
    y1=y1-max(y1)#
    y2=y2-max(y2)#
   	y3=y3-max(y3)#
   	y1=exp(y1)#
   	y2=exp(y2)#
   	y3=exp(y3)#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}#
#
trian=get_dens(Dat,metric)#
#
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
dev.new()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=TRUE, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,0.96),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="x2",pos=2)#
panel.text(.1,.45,label="x1",pos=4)#
panel.text(.5,-.05,label="x3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))
trellis.focus("panel", 1, 1, highlight=FALSE)
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))
grade.trellis()
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
I(1!=2)
I(1!=2)*1
metric=function(x,y){#
	return(1*I(x!=y))#
}
trian=get_dens(Dat,metric)
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, colorkey=TRUE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
?levelplot
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, #
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE, #
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)),default.theme=standard.theme(color=F))
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=tray(0:100/100)#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(0:100/100),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(0:100/100),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(0:100/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(0:100/20),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL, contour=F, labels=FALSE,col.regions=gray(100:200/200),#
          par.settings=list(axis.line=list(col=NA), axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")))#
         )#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")))#
         col=graey(sqe(100,200,20)))
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=graey(sqe(100,200,20)))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(sqe(100,200,20)))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(seq(100,200,20)))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),#
         labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(seq(100,200,20)/200))#
         )
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
colorkey=list(at=as.numeric(factor(c(seq(from=0,to=1,by=0.2)))),labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(seq(100,200,20)/200)))
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=seq(0,1,0.2),    labels=as.character(c("0","0.2","0.4","0.6","0.8","1")),col=gray(seq(100,200,20)/200))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=seq(0,1,0.2),    labels=c("0","0.2","0.4","0.6","0.8","1"),col=gray(seq(100,200,20)/200))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         #par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)),#
         colorkey=list(at=seq(0,1,0.2),    labels=c("0","0.2","0.4","0.6","0.8","1"),col=gray(seq(100,200,20)/200))#
         )
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=1)),#
         colorkey=list(at=seq(0,1,0.2),    labels=c("0","0.2","0.4","0.6","0.8","1"),col=gray(seq(100,200,20)/200))#
         )
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=1)),#
         colorkey=list(at=seq(0,1,0.2),    labels=c("0","0.2","0.4","0.6","0.8","1"),col=gray(seq(100,200,20)/200))#
         )
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
y1
min(trian$y1)
min(trian$y2)
min(trian$y3)
require(mixexp)#
#
l1=function(Dat,p){#
	#likelihood function#
	l=matrix(Dat,1,3)%*%as.matrix(log(p),1,3)#
	return(l)#
}#
#
l2=function(Dat,metric,p){#
	#expectation of loss function#
	l=-matrix(Dat,1,3)%*%outer(1:3,1:3,metric)%*%as.matrix(p,1,3)#
	return(l)#
}#
#
l3=function(Dat,metric,p){#
	#original loss function#
	rhat=which.max(p)#
	l=-matrix(Dat,1,3)%*%outer(1:3,rhat,metric)#
	return(l)#
}#
#
metric=function(x,y){#
	return((x-y)^2)#
}#
#
## Create function to place grid lines and axis labels on the plot.#
grade.trellis <- function(from=0.2, to=0.8, step=0.2, col=1, lty=2, lwd=0.5){#
  x1 <- seq(from, to, step)#
  x2 <- x1/2#
  y2 <- x1*sqrt(3)/2#
  x3 <- (1-x1)*0.5+x1#
  y3 <- sqrt(3)/2-x1*sqrt(3)/2#
  panel.segments(x1, 0, x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x1, 0, label=x1, pos=1)#
  panel.segments(x1, 0, x3, y3, col=col, lty=lty, lwd=lwd)#
  panel.text(x2, y2, label=rev(x1), pos=2)#
  panel.segments(x2, y2, 1-x2, y2, col=col, lty=lty, lwd=lwd)#
  panel.text(x3, y3, label=rev(x1), pos=4)#
}#
#
#a function to calculate 'likelihood' in 3 different ways#
Dat=c(10,4,6)#
#
get_dens=function(Dat,metric,d=0.01){#
	#Dat has length of 3, the numbers are appearance of ratings=1, 2 and 3#
	#metric is a function of the form f(x,y), which measures the distance between x and y#
	#d is the distance between points in the output#
	#there're 6 columns of outdata first 3 are p1,p2,p3#
	#last 3 are corresponding 'likelihood'#
	trian <- expand.grid(base=seq(0,1,l=100*2), high=seq(0,sin(pi/3),l=87*2))#
	trian <- subset(trian, (base*sin(pi/3)*2)>high)#
	trian <- subset(trian, ((1-base)*sin(pi/3)*2)>high)#
	p2=trian$high*2/sqrt(3)#
    p3=trian$base-trian$high/sqrt(3)#
    p1=1-p3-p2#
    y1=matrix(0,0,1)#
    y2=matrix(0,0,1)#
    y3=matrix(0,0,1)#
    for (i in 1:length(p1)){#
    	p=c(p1[i],p2[i],p3[i])#
    	y1=rbind(y1,l1(Dat,p))#
    	y2=rbind(y2,l2(Dat,metric,p))#
    	y3=rbind(y3,l3(Dat,metric,p))#
    }#
    y1=y1-max(y1)#
    y2=y2-max(y2)#
   	y3=y3-max(y3)#
   	y1=exp(y1)#
   	y2=exp(y2)#
   	y3=exp(y3)#
    trian$y1=y1#
    trian$y2=y2#
    trian$y3=y3#
#
	return(trian)#
}
trian=get_dens(Dat,metric)
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(100:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.05,label="p3",pos=1)#
trellis.unfocus()
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,-.,label="p3",pos=1)#
trellis.unfocus()
trian=get_dens(Dat,metric)#
#
levelplot(y3~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,0,label="p3",pos=1)#
trellis.unfocus()
levelplot(y2~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,0,label="p3",pos=1)#
trellis.unfocus()
levelplot(y1~base*high, trian, aspect="iso", xlim=c(-0.1,1.1), ylim=c(-0.1,1.1),#
          xlab=NULL, ylab=NULL,contour=F,labels=FALSE,col.regions=gray(50:200/200),#
         par.settings=list(axis.line=list(col=NA),axis.text=list(col=NA)))#
trellis.focus("panel", 1, 1, highlight=FALSE)#
panel.segments(c(0,0,0.5), c(0,0,sqrt(3)/2), c(1,1/2,1), c(0,sqrt(3)/2,0))#
grade.trellis()#
panel.text(.9,.45,label="p2",pos=2)#
panel.text(.1,.45,label="p1",pos=4)#
panel.text(.5,0,label="p3",pos=1)#
trellis.unfocus()
vc=6#
eps=0.01#
512*vc/eps^2*log(256*vc/eps^2)
vc=6#
eps=1#
512*vc/eps^2*log(256*vc/eps^2)
vc=6#
eps=1#
n=512*vc/(eps^2)*log(256*vc/(eps^2))#
n^nc#
e^(n*eps^2)/256
vc=6#
eps=1#
n=512*vc/(eps^2)*log(256*vc/(eps^2))#
n^nc#
exp((n*eps^2)/256)
vc=6#
eps=1#
n=512*vc/(eps^2)*log(256*vc/(eps^2))#
n^vc#
exp((n*eps^2)/256)
1-pnorm(1.776)
test<-function(a,b){#
	line<-function(x){#
		y=a+b*x#
		y#
	}#
	line#
}
l1=test(1,2)
l1
l1(5)
setwd("./Desktop/ranking/code/binary_BLP/")
source("./binary_functions.R")#
#
##plot the case in 1 dimension#
t=1#
m=100#
nt=100#
n1=m*0.5#
n2=m-n1#
Gen=gen_bin_data(m+nt,p,3,0)#
totalDat=Gen$Dat#
Dat=totalDat[1:n1,]#
vDat=totalDat[(n1+1):(n1+n2),]#
tDat=totalDat[(m+1):(m+nt),]#
#calculate proper value of sigma and kappa#
result=SA_bin_BLP(Dat,vDat)#
ker=gen_ker(result$kappa)#
x=as.matrix(seq(-5,5,0.01))#
plot(x,get_f(Dat[,2],getSigma(Dat[,1],ker),getcov(Dat[,1],x,ker),result$sig),ylim=c(-1,1),type='l')#
points(totalDat[,1],Gen$f/max(abs(Gen$f)))#
geterr(Dat,tDat,result$kappa,result$sig)
source("./binary_functions.R")#
#
##plot the case in 1 dimension#
t=1#
p=1#
m=100#
nt=100#
n1=m*0.5#
n2=m-n1#
Gen=gen_bin_data(m+nt,p,3,0)#
totalDat=Gen$Dat#
Dat=totalDat[1:n1,]#
vDat=totalDat[(n1+1):(n1+n2),]#
tDat=totalDat[(m+1):(m+nt),]#
#calculate proper value of sigma and kappa#
result=SA_bin_BLP(Dat,vDat)#
ker=gen_ker(result$kappa)#
x=as.matrix(seq(-5,5,0.01))#
plot(x,get_f(Dat[,2],getSigma(Dat[,1],ker),getcov(Dat[,1],x,ker),result$sig),ylim=c(-1,1),type='l')#
points(totalDat[,1],Gen$f/max(abs(Gen$f)))#
geterr(Dat,tDat,result$kappa,result$sig)
library(mvtnorm)#to generate multivariate normal r.v#
#
gen_ker<-function(kappa=2){#
	#function to generate kernel function specified by kappa#
	ker<-function(x1,x2){#
		#kernal function to generate Sigma#
		k=sum((x1-x2)^2)#
		K=exp(-kappa*k/2)#
		K#
	}#
	ker#
}#
#
getSigma<-function(x,ker){#
	#Get the covariance function given x values and kernel#
	x=as.matrix(x)#
	n=nrow(x)#
	Sigma=matrix(1,n,n)#
	for (i in 2:n){#
		for (j in 1:(i-1)){#
			Sigma[i,j]=ker(x[i,],x[j,])#
			Sigma[j,i]=Sigma[i,j]#
		}#
	}	#
	Sigma#
}#
#
getcov<-function(x0,x1,ker){#
	#Return a matrix where (i,j)th entry is K(x1_i,x0_j)#
	x0=as.matrix(x0)#
	x1=as.matrix(x1)#
	n0=nrow(x0)#
	n1=nrow(x1)#
	Cov=matrix(1,n1,n0)#
	for (i in 1:n0){#
		for (j in 1:n1){#
			Cov[j,i]=ker(x1[j,],x0[i,])#
		}#
	}#
	Cov#
}#
gen_bin_data<-function(n,p,type=1,errsd=0){#
	#generate a dataset with n observations and p covaraites#
	#the binary value of Y is decided by x in 2 ways:#
	#type=1: Y=I(sum(b_i*x_i>0)), where x_i is the ith covariate of x#
	#type=2: Y=I(sum(b_i*x_i^2>mean(b_i*x_i^2)))#
	#all of the x are from Unif(0,10),b are from N(0,1)#
	x=matrix(runif(n*p)*10-5,n,p)#
	b=rnorm(p)#
	if (type==1){#
		f=x%*%b+rnorm(n,0,errsd)#
	}else if (type==2){#
		f=x^2%*%b+rnorm(n,0,errsd)#
		f=f-mean(f)#
	}else if (type==3){#
		f=sin(x%*%b+rnorm(n,0,errsd)#
)#
	}#
	Y=I(f>0)*2-1#
	Dat=cbind(x,Y)#
	list(Dat=Dat,f=f)#
}#
#
pre_bin_BLP<-function(y,Sig,Cov,sig){#
	est=get_f(y,Sig,Cov,sig)#
	est=I(est>0)*2-1#
	est#
}#
get_f<-function(y,Sig,Cov,sig){#
	inv_sig=solve(Sig)#
	est=Cov%*%inv_sig%*%solve(inv_sig+diag(ncol(Sig)))%*%y#
}#
geterr<-function(Dat,tDat,kappa,sig){#
	p=ncol(Dat)#
	x=Dat[,1:(p-1)]#
	y=Dat[,p]#
	tx=as.matrix(tDat[,1:(p-1)])#
	ty=as.matrix(tDat[,p])#
	ker=gen_ker(kappa)#
	Sig=getSigma(x,ker)#
	Cov=getcov(x,tx,ker)#
	est=pre_bin_BLP(y,Sig,Cov,sig)#
	l=sum(est!=ty)#
	l#
}#
SA_bin_BLP<-function(Dat,vDat){#
	#simulated annealing method to find proper values of sigma and kappa#
	#Dat is the training data#
	#vDat is the validating data#
	kmax=5e3#
	p=ncol(Dat)#
	Y=Dat[,p]#
	vY=vDat[,p]#
	x=as.matrix(Dat[,1:p-1])#
	vx=as.matrix(vDat[,1:p-1])#
	p=p-1#
	#tolc,sig_kappa,sig_sig are parameters used by simulated annealing alg#
	tolc=1#
	sig_kappa=5#
	sig_sig=1#
	count=0#
	errcount=0#
	for (k in 1:kmax){#
		if (k==1){#
			#initialize#
			kappa=20#
			sig=1#
			ker=gen_ker(kappa)#
			Sig=getSigma(x,ker)#
			Cov=getcov(x,vx,ker)#
			#vYhat is the estimated values of Y based on data in validation set#
			vYhat=pre_bin_BLP(Y,Sig,Cov,sig)#
			l=sum(vYhat!=vY)#
			newl=Inf#
		}#
		newkappa=abs(kappa+rnorm(1,0,sig_kappa))#
		newsig=abs(sig+rnorm(1,0,sig_sig))#
		newker=gen_ker(newkappa)#
		newSig=getSigma(x,newker)#
		newCov=getcov(x,vx,newker)#
		PossibleErr=tryCatch({#
			newvYhat=pre_bin_BLP(Y,newSig,newCov,newsig)#
			newl=sum(newvYhat!=vY)#
		},error=function(e){#
			errcount=errcount+1#
			e})#
		if (inherits(PossibleErr,"Error")){#
			next#
		}#
		temp=runif(1,0,1)#
		if (temp<(exp(tolc*(l-newl)))){#
			sig=newsig#
			kappa=newkappa#
			l=newl#
			count=count+1#
		}#
		if((k%%200)==0){#
			#adjust tol and sig by accept rate#
			accrate=count/200#
			if(accrate>0.5){#
				tolc=tolc*5#
			}else{#
				sig_sig=sig_sig*0.8#
				sig_kappa=sig_kappa*0.8#
			}#
			count=0#
		}#
	}#
	list(kappa=kappa,sig=sig,err=l/length(vY))#
}
source("./binary_functions.R")#
#
##plot the case in 1 dimension#
t=1#
p=1#
m=100#
nt=100#
n1=m*0.5#
n2=m-n1#
Gen=gen_bin_data(m+nt,p,3,0)#
totalDat=Gen$Dat#
Dat=totalDat[1:n1,]#
vDat=totalDat[(n1+1):(n1+n2),]#
tDat=totalDat[(m+1):(m+nt),]#
#calculate proper value of sigma and kappa#
result=SA_bin_BLP(Dat,vDat)#
ker=gen_ker(result$kappa)#
x=as.matrix(seq(-5,5,0.01))#
plot(x,get_f(Dat[,2],getSigma(Dat[,1],ker),getcov(Dat[,1],x,ker),result$sig),ylim=c(-1,1),type='l')#
points(totalDat[,1],Gen$f/max(abs(Gen$f)))#
geterr(Dat,tDat,result$kappa,result$sig)
source("./binary_functions.R")
source("./binary_functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
nt=200#
l=1#
for (p in c(3,20)){#
	E1=matrix(NA,5,2)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:2){#
		j=1#
		for (m in c(100,500)){#
			#n0 is the size of 'total' training set#
			#nt is the size of testing set#
			#n1 is the size of 'true' training set#
			#n2 is the size of validating set#
			n1=m*0.5#
			n2=m-n1#
			rep=10#
			totalDat=gen_bin_data(m+nt,p,t)#
			Dat=totalDat[1:n1,]#
			vDat=totalDat[(n1+1):(n1+n2),]#
			tDat=totalDat[(m+1):(m+nt),]#
			#calculate proper value of sigma and kappa#
			result=SA_bin_BLP(Dat,vDat)#
			e1=geterr(Dat,tDat,result$kappa,result$sig)/nt#
			e2=geterr(Dat,vDat,result$kappa,result$sig)/n2#
			e3=geterr(Dat,Dat,result$kappa,result$sig)/n1#
			print (sprintf("p:%i, t:%i, m: %i",p,t,m))#
			print (sprintf("testing error: %f, validating error: %f, training error: %f.",e1,e2,e3))	#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
save(TE1,TE2,TE3,file="./binary_BLP.Rdata")
totalDat=gen_bin_data(m+nt,p,t)$Dat
source("./binary_functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
nt=200#
l=1#
for (p in c(3,20)){#
	E1=matrix(NA,5,2)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:2){#
		j=1#
		for (m in c(100,500)){#
			#n0 is the size of 'total' training set#
			#nt is the size of testing set#
			#n1 is the size of 'true' training set#
			#n2 is the size of validating set#
			n1=m*0.5#
			n2=m-n1#
			rep=10#
			totalDat=gen_bin_data(m+nt,p,t)$Dat#
			Dat=totalDat[1:n1,]#
			vDat=totalDat[(n1+1):(n1+n2),]#
			tDat=totalDat[(m+1):(m+nt),]#
			#calculate proper value of sigma and kappa#
			result=SA_bin_BLP(Dat,vDat)#
			e1=geterr(Dat,tDat,result$kappa,result$sig)/nt#
			e2=geterr(Dat,vDat,result$kappa,result$sig)/n2#
			e3=geterr(Dat,Dat,result$kappa,result$sig)/n1#
			print (sprintf("p:%i, t:%i, m: %i",p,t,m))#
			print (sprintf("testing error: %f, validating error: %f, training error: %f.",e1,e2,e3))	#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
save(TE1,TE2,TE3,file="./binary_BLP.Rdata")
TE1
source("./binary_functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
nt=200#
l=1#
for (p in c(3,20)){#
	E1=matrix(NA,5,2)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:2){#
		j=1#
		for (m in c(100,500)){#
			#n0 is the size of 'total' training set#
			#nt is the size of testing set#
			#n1 is the size of 'true' training set#
			#n2 is the size of validating set#
			n1=m*0.5#
			n2=m-n1#
			rep=10#
			totalDat=gen_bin_data(m+nt,p,t)$Dat#
			Dat=totalDat[1:n1,]#
			vDat=totalDat[(n1+1):(n1+n2),]#
			tDat=totalDat[(m+1):(m+nt),]#
			#calculate proper value of sigma and kappa#
			result=SA_bin_BLP(Dat,vDat)#
			e1=geterr(Dat,tDat,result$kappa,result$sig)/nt#
			e2=geterr(Dat,vDat,result$kappa,result$sig)/n2#
			e3=geterr(Dat,Dat,result$kappa,result$sig)/n1#
			print (sprintf("p:%i, t:%i, m: %i",p,t,m))#
			print (sprintf("testing error: %f, validating error: %f, training error: %f.",e1,e2,e3))	#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
save(TE1,TE2,TE3,file="./binary_BLP.Rdata")
source("./binary_functions.R")#
#
##plot the case in 1 dimension#
t=1#
p=1#
m=100#
nt=100#
n1=m*0.5#
n2=m-n1#
Gen=gen_bin_data(m+nt,p,3,0)#
totalDat=Gen$Dat#
Dat=totalDat[1:n1,]#
vDat=totalDat[(n1+1):(n1+n2),]#
tDat=totalDat[(m+1):(m+nt),]#
#calculate proper value of sigma and kappa#
result=SA_bin_BLP(Dat,vDat)#
ker=gen_ker(result$kappa)#
x=as.matrix(seq(-5,5,0.01))#
plot(x,get_f(Dat[,2],getSigma(Dat[,1],ker),getcov(Dat[,1],x,ker),result$sig),ylim=c(-1,1),type='l')#
points(totalDat[,1],Gen$f/max(abs(Gen$f)))#
geterr(Dat,tDat,result$kappa,result$sig)
source("./binary_functions.R")#
#
##plot the case in 1 dimension#
t=1#
p=1#
m=100#
nt=100#
n1=m*0.5#
n2=m-n1#
Gen=gen_bin_data(m+nt,p,3,0)#
totalDat=Gen$Dat#
Dat=totalDat[1:n1,]#
vDat=totalDat[(n1+1):(n1+n2),]#
tDat=totalDat[(m+1):(m+nt),]#
#calculate proper value of sigma and kappa#
result=SA_bin_BLP(Dat,vDat)#
ker=gen_ker(result$kappa)#
x=as.matrix(seq(-5,5,0.01))#
plot(x,get_f(Dat[,2],getSigma(Dat[,1],ker),getcov(Dat[,1],x,ker),result$sig),ylim=c(-1,1),type='l')#
points(totalDat[,1],Gen$f/max(abs(Gen$f)))#
geterr(Dat,tDat,result$kappa,result$sig)
source("./binary_functions.R")#
#
##plot the case in 1 dimension#
t=1#
p=1#
m=100#
nt=100#
n1=m*0.5#
n2=m-n1#
Gen=gen_bin_data(m+nt,p,3,0)#
totalDat=Gen$Dat#
Dat=totalDat[1:n1,]#
vDat=totalDat[(n1+1):(n1+n2),]#
tDat=totalDat[(m+1):(m+nt),]#
#calculate proper value of sigma and kappa#
result=SA_bin_BLP(Dat,vDat)#
ker=gen_ker(result$kappa)#
x=as.matrix(seq(-5,5,0.01))#
plot(x,get_f(Dat[,2],getSigma(Dat[,1],ker),getcov(Dat[,1],x,ker),result$sig),ylim=c(-1,1),type='l')#
points(totalDat[,1],Gen$f/max(abs(Gen$f)))#
geterr(Dat,tDat,result$kappa,result$sig)
inherits(PossibleErr,"Error")
kappa=2#
			sig=1#
			ker=gen_ker(kappa)#
			Sig=getSigma(x,ker)#
			Cov=getcov(x,vx,ker)#
			#vYhat is the estimated values of Y based on data in validation set#
			Err=T
while (Err==T){#
				PossibleErr=tryCatch(#
				{#
					vYhat=pre_bin_BLP(Y,Sig,Cov,sig)#
				},#
				error=function(e){#
					print (e)#
					e	#
				}#
				)#
				print (PossibleErr)
Err=inherits(PossibleErr,"Error")#
				print(Err)#
				if (Err){#
					kappa=kappa+5#
					ker=gen_ker(kappa)#
					Sig=getSigma(x,ker)#
					Cov=getcov(x,vx,ker)#
				}#
			}
?inherits
class(PossibleErr)
inherits(PossibleErr,"error")
source("./binary_functions.R")#
#
##plot the case in 1 dimension#
t=1#
p=1#
m=100#
nt=100#
n1=m*0.5#
n2=m-n1#
Gen=gen_bin_data(m+nt,p,3,0)#
totalDat=Gen$Dat#
Dat=totalDat[1:n1,]#
vDat=totalDat[(n1+1):(n1+n2),]#
tDat=totalDat[(m+1):(m+nt),]#
#calculate proper value of sigma and kappa#
result=SA_bin_BLP(Dat,vDat)#
ker=gen_ker(result$kappa)#
x=as.matrix(seq(-5,5,0.01))#
plot(x,get_f(Dat[,2],getSigma(Dat[,1],ker),getcov(Dat[,1],x,ker),result$sig),ylim=c(-1,1),type='l')#
points(totalDat[,1],Gen$f/max(abs(Gen$f)))#
geterr(Dat,tDat,result$kappa,result$sig)
rm(list=ls())
setwd("../GP_Gibbs/")
ls
source("./functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
mt=2000#
l=1#
for (p in c(3,20)){#
	E1=matrix(NA,5,2)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:5){#
		j=1#
		for (m in c(100,500)){#
			m1=10#
			m2=m-m1#
			Gen=gendata(150,p,type=t)#
			Dat=Gen$Dat#
			nc=ncol(Dat)#
			y=Dat[,nc]#
			Dat=Dat[,1:(nc-1)]#
			#generate training data and calculate X,Z#
			newDat=samplepairs(m1,Dat,y)#
			valDat=samplepairs(m2,Dat,y)#
			tesDat=samplepairs(mt,Dat,y)#
			cDat=convertDat(newDat)#
			vcDat=convertDat(valDat)#
			tcDat=convertDat(tesDat)#
			result0=SA_GP(cDat,2,kmax=1e4)#
			result=SA_GP_v(vcDat,result0$fI,cDat,kmax=1e3)#
			x=cDat$points#
			kappa=result$kappa#
			ker=gen_ker(kappa)#
			fI=result$fI#
			Sig=result$Sig#
			pre=pre_GP(getcov(tcDat$points,x,ker),Sig,fI)#
			e1=loss_GP(pre,tcDat$pairs)/mt#
			e2=loss_GP(pre_GP(getcov(vcDat$points,x,ker),Sig,fI),vcDat$pairs)/m2#
			e3=loss_GP(fI,cDat$pairs)/m1#
			msg=sprintf("p: %i, type: %i, m: %i ", p,t,m)#
			print(msg)#
			msg1=sprintf("kappa: %f",result$kappa)#
			print(msg1)#
			msg2=sprintf("testing err: %f, validating err: %f, training err: %f",e1,e2,e3)#
			print(msg2)#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
#
save(TE1,TE2,TE3,file="./simu_GPv.Rdata")
source("./functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
mt=2000#
l=1#
for (p in c(20)){#
	E1=matrix(NA,5)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:5){#
		j=1#
		for (m in c(100,500)){#
			m1=10#
			m2=m-m1#
			Gen=gendata(150,p,type=t)#
			Dat=Gen$Dat#
			nc=ncol(Dat)#
			y=Dat[,nc]#
			Dat=Dat[,1:(nc-1)]#
			#generate training data and calculate X,Z#
			newDat=samplepairs(m1,Dat,y)#
			valDat=samplepairs(m2,Dat,y)#
			tesDat=samplepairs(mt,Dat,y)#
			cDat=convertDat(newDat)#
			vcDat=convertDat(valDat)#
			tcDat=convertDat(tesDat)#
			result0=SA_GP(cDat,2,kmax=1e4)#
			result=SA_GP_v(vcDat,result0$fI,cDat,kmax=1e3)#
			x=cDat$points#
			kappa=result$kappa#
			ker=gen_ker(kappa)#
			fI=result$fI#
			Sig=result$Sig#
			pre=pre_GP(getcov(tcDat$points,x,ker),Sig,fI)#
			e1=loss_GP(pre,tcDat$pairs)/mt#
			e2=loss_GP(pre_GP(getcov(vcDat$points,x,ker),Sig,fI),vcDat$pairs)/m2#
			e3=loss_GP(fI,cDat$pairs)/m1#
			msg=sprintf("p: %i, type: %i, m: %i ", p,t,m)#
			print(msg)#
			msg1=sprintf("kappa: %f",result$kappa)#
			print(msg1)#
			msg2=sprintf("testing err: %f, validating err: %f, training err: %f",e1,e2,e3)#
			print(msg2)#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
#
save(TE1,TE2,TE3,file="./simu_GPv.Rdata")
jj
j
i
source("./functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
mt=2000#
l=1#
for (p in c(20)){#
	E1=matrix(NA,5,1)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:5){#
		j=1#
		for (m in c(100,500)){#
			m1=10#
			m2=m-m1#
			Gen=gendata(150,p,type=t)#
			Dat=Gen$Dat#
			nc=ncol(Dat)#
			y=Dat[,nc]#
			Dat=Dat[,1:(nc-1)]#
			#generate training data and calculate X,Z#
			newDat=samplepairs(m1,Dat,y)#
			valDat=samplepairs(m2,Dat,y)#
			tesDat=samplepairs(mt,Dat,y)#
			cDat=convertDat(newDat)#
			vcDat=convertDat(valDat)#
			tcDat=convertDat(tesDat)#
			result0=SA_GP(cDat,2,kmax=1e4)#
			result=SA_GP_v(vcDat,result0$fI,cDat,kmax=1e3)#
			x=cDat$points#
			kappa=result$kappa#
			ker=gen_ker(kappa)#
			fI=result$fI#
			Sig=result$Sig#
			pre=pre_GP(getcov(tcDat$points,x,ker),Sig,fI)#
			e1=loss_GP(pre,tcDat$pairs)/mt#
			e2=loss_GP(pre_GP(getcov(vcDat$points,x,ker),Sig,fI),vcDat$pairs)/m2#
			e3=loss_GP(fI,cDat$pairs)/m1#
			msg=sprintf("p: %i, type: %i, m: %i ", p,t,m)#
			print(msg)#
			msg1=sprintf("kappa: %f",result$kappa)#
			print(msg1)#
			msg2=sprintf("testing err: %f, validating err: %f, training err: %f",e1,e2,e3)#
			print(msg2)#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
#
save(TE1,TE2,TE3,file="./simu_GPv.Rdata")
j
i
m1=10#
			m2=m-m1#
			Gen=gendata(150,p,type=t)#
			Dat=Gen$Dat#
			nc=ncol(Dat)#
			y=Dat[,nc]#
			Dat=Dat[,1:(nc-1)]#
			#generate training data and calculate X,Z#
			newDat=samplepairs(m1,Dat,y)#
			valDat=samplepairs(m2,Dat,y)#
			tesDat=samplepairs(mt,Dat,y)#
			cDat=convertDat(newDat)#
			vcDat=convertDat(valDat)#
			tcDat=convertDat(tesDat)
result0=SA_GP(cDat,2,kmax=1e4)#
			result=SA_GP_v(vcDat,result0$fI,cDat,kmax=1e3)#
			x=cDat$points
kappa=result$kappa#
			ker=gen_ker(kappa)#
			fI=result$fI#
			Sig=result$Sig#
			pre=pre_GP(getcov(tcDat$points,x,ker),Sig,fI)#
			e1=loss_GP(pre,tcDat$pairs)/mt#
			e2=loss_GP(pre_GP(getcov(vcDat$points,x,ker),Sig,fI),vcDat$pairs)/m2#
			e3=loss_GP(fI,cDat$pairs)/m1
i
j
E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3
E1
source("./functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
mt=2000#
l=1#
for (p in c(3,20)){#
	E1=matrix(NA,5,2)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:5){#
		j=1#
		for (m in c(100,500)){#
			m1=10#
			m2=m-m1#
			Gen=gendata(150,p,type=t)#
			Dat=Gen$Dat#
			nc=ncol(Dat)#
			y=Dat[,nc]#
			Dat=Dat[,1:(nc-1)]#
			#generate training data and calculate X,Z#
			newDat=samplepairs(m1,Dat,y)#
			valDat=samplepairs(m2,Dat,y)#
			tesDat=samplepairs(mt,Dat,y)#
			cDat=convertDat(newDat)#
			vcDat=convertDat(valDat)#
			tcDat=convertDat(tesDat)#
			result0=SA_GP(cDat,2,kmax=1e4)#
			result=SA_GP_v(vcDat,result0$fI,cDat,kmax=1e3)#
			x=cDat$points#
			kappa=result$kappa#
			ker=gen_ker(kappa)#
			fI=result$fI#
			Sig=result$Sig#
			pre=pre_GP(getcov(tcDat$points,x,ker),Sig,fI)#
			e1=loss_GP(pre,tcDat$pairs)/mt#
			e2=loss_GP(pre_GP(getcov(vcDat$points,x,ker),Sig,fI),vcDat$pairs)/m2#
			e3=loss_GP(fI,cDat$pairs)/m1#
			msg=sprintf("p: %i, type: %i, m: %i ", p,t,m)#
			print(msg)#
			msg1=sprintf("kappa: %f",result$kappa)#
			print(msg1)#
			msg2=sprintf("testing err: %f, validating err: %f, training err: %f",e1,e2,e3)#
			print(msg2)#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
#
save(TE1,TE2,TE3,file="./simu_GPv.Rdata")
source("./functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
mt=2000#
l=1#
for (p in c(3,20)){#
	E1=matrix(NA,5,2)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:5){#
		j=1#
		for (m in c(100,500)){#
			m1=3#
			m2=m-m1#
			Gen=gendata(150,p,type=t)#
			Dat=Gen$Dat#
			nc=ncol(Dat)#
			y=Dat[,nc]#
			Dat=Dat[,1:(nc-1)]#
			#generate training data and calculate X,Z#
			newDat=samplepairs(m1,Dat,y)#
			valDat=samplepairs(m2,Dat,y)#
			tesDat=samplepairs(mt,Dat,y)#
			cDat=convertDat(newDat)#
			vcDat=convertDat(valDat)#
			tcDat=convertDat(tesDat)#
			result0=SA_GP(cDat,2,kmax=1e4)#
			result=SA_GP_v(vcDat,result0$fI,cDat,kmax=1e3)#
			x=cDat$points#
			kappa=result$kappa#
			ker=gen_ker(kappa)#
			fI=result$fI#
			Sig=result$Sig#
			pre=pre_GP(getcov(tcDat$points,x,ker),Sig,fI)#
			e1=loss_GP(pre,tcDat$pairs)/mt#
			e2=loss_GP(pre_GP(getcov(vcDat$points,x,ker),Sig,fI),vcDat$pairs)/m2#
			e3=loss_GP(fI,cDat$pairs)/m1#
			msg=sprintf("p: %i, type: %i, m: %i ", p,t,m)#
			print(msg)#
			msg1=sprintf("kappa: %f",result$kappa)#
			print(msg1)#
			msg2=sprintf("testing err: %f, validating err: %f, training err: %f",e1,e2,e3)#
			print(msg2)#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
#
save(TE1,TE2,TE3,file="./simu_GPv.Rdata")
source("./functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
mt=200#
l=1#
for (p in c(3,20)){#
	E1=matrix(NA,5,2)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:5){#
		j=1#
		for (m in c(100,500)){#
			m1=3#
			m2=m-m1#
			Gen=gendata(150,p,type=t)#
			Dat=Gen$Dat#
			nc=ncol(Dat)#
			y=Dat[,nc]#
			Dat=Dat[,1:(nc-1)]#
			#generate training data and calculate X,Z#
			newDat=samplepairs(m1,Dat,y)#
			valDat=samplepairs(m2,Dat,y)#
			tesDat=samplepairs(mt,Dat,y)#
			cDat=convertDat(newDat)#
			vcDat=convertDat(valDat)#
			tcDat=convertDat(tesDat)#
			result0=SA_GP(cDat,2,kmax=1e4)#
			result=SA_GP_v(vcDat,result0$fI,cDat,kmax=1e3)#
			x=cDat$points#
			kappa=result$kappa#
			ker=gen_ker(kappa)#
			fI=result$fI#
			Sig=result$Sig#
			pre=pre_GP(getcov(tcDat$points,x,ker),Sig,fI)#
			e1=loss_GP(pre,tcDat$pairs)/mt#
			e2=loss_GP(pre_GP(getcov(vcDat$points,x,ker),Sig,fI),vcDat$pairs)/m2#
			e3=loss_GP(fI,cDat$pairs)/m1#
			msg=sprintf("p: %i, type: %i, m: %i ", p,t,m)#
			print(msg)#
			msg1=sprintf("kappa: %f",result$kappa)#
			print(msg1)#
			msg2=sprintf("testing err: %f, validating err: %f, training err: %f",e1,e2,e3)#
			print(msg2)#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
#
save(TE1,TE2,TE3,file="./simu_GPv.Rdata")
source("./functions.R")#
TE1=list(p3=NULL,p20=NULL)#
TE2=list(p3=NULL,p20=NULL)#
TE3=list(p3=NULL,p20=NULL)#
mt=200#
l=1#
for (p in c(3,20)){#
	E1=matrix(NA,5,2)#
	E2=E1#
	E3=E1#
	i=1#
	for (t in 1:5){#
		j=1#
		for (m in c(100,500)){#
			m1=1#
			m2=m-m1#
			Gen=gendata(150,p,type=t)#
			Dat=Gen$Dat#
			nc=ncol(Dat)#
			y=Dat[,nc]#
			Dat=Dat[,1:(nc-1)]#
			#generate training data and calculate X,Z#
			newDat=samplepairs(m1,Dat,y)#
			valDat=samplepairs(m2,Dat,y)#
			tesDat=samplepairs(mt,Dat,y)#
			cDat=convertDat(newDat)#
			vcDat=convertDat(valDat)#
			tcDat=convertDat(tesDat)#
			result0=SA_GP(cDat,2,kmax=1e4)#
			result=SA_GP_v(vcDat,result0$fI,cDat,kmax=1e3)#
			x=cDat$points#
			kappa=result$kappa#
			ker=gen_ker(kappa)#
			fI=result$fI#
			Sig=result$Sig#
			pre=pre_GP(getcov(tcDat$points,x,ker),Sig,fI)#
			e1=loss_GP(pre,tcDat$pairs)/mt#
			e2=loss_GP(pre_GP(getcov(vcDat$points,x,ker),Sig,fI),vcDat$pairs)/m2#
			e3=loss_GP(fI,cDat$pairs)/m1#
			msg=sprintf("p: %i, type: %i, m: %i ", p,t,m)#
			print(msg)#
			msg1=sprintf("kappa: %f",result$kappa)#
			print(msg1)#
			msg2=sprintf("testing err: %f, validating err: %f, training err: %f",e1,e2,e3)#
			print(msg2)#
			E1[i,j]=e1#
			E2[i,j]=e2	#
			E3[i,j]=e3#
			j=j+1#
		}#
		i=i+1#
	}#
	TE1[[l]]=E1#
	TE2[[l]]=E2#
	TE3[[l]]=E3#
	l=l+1#
}#
#
save(TE1,TE2,TE3,file="./simu_GPv.Rdata")
rm(list=ls())
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=c(1,1.9,2,2.1,3)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(1,20)){#
		obs_y=c(-1,-1,1.5,-0.5,1)*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=c(1,3)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(1,20)){#
		obs_y=c(1,-1)*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=c(1,3)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(0.1,20)){#
		obs_y=c(1,-1)*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=c(1,3)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(0.1,50)){#
		obs_y=c(1,-1)*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=c(1,2,3)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(0.1,50)){#
		obs_y=c(1,1,-1)*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=c(1,2,3)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(0.01,50)){#
		obs_y=c(1,1,-1)*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=c(1,2,3)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(1,50)){#
		obs_y=c(1,1,-1)*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=c(1,2,3)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(1,100)){#
		obs_y=c(1,1,-1)*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=seq(-3,3,0.1)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(1,100)){#
		obs_y=rnorm(length(obs_x))*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=seq(-3,3,0.5)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
for (const in c(0.5,1)){#
	for (ka in c(1,100)){#
		obs_y=rnorm(length(obs_x))*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=seq(-3,3,0.5)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(0.5,1)){#
	for (ka in c(1,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=seq(0,5,0.5)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(0.5,1)){#
	for (ka in c(1,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=seq(0,5,0.5)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=seq(0,5,0.5)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=seq(0,5,0.1)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,5,0.1)#
obs_x=seq(0,5,0.2)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,10,0.1)#
obs_x=seq(0,10,0.2)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,0.1)#
obs_x=seq(0,100,0.2)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,5)#
obs_x=seq(0,100,2)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,2)#
obs_x=seq(0,100,2)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,1)#
obs_x=seq(0,100,2)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,0.5)#
obs_x=seq(0,100,2)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
dev()
new(dev)
new.dev()
dev.new()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,0.5)#
obs_x=seq(0,100,20)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,0.5)#
obs_x=seq(0,100,20)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(0.01,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,0.5)#
obs_x=seq(0,100,2)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(0.01,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,0.5)#
obs_x=seq(0,100,2)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(0.1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
dev(1)
quartz(1)
dev.new()
kernel1<-function(x1,x2,kappa=1){#
	#kernal function to generate Sigma#
	k=sum((x1-x2)^2)#
	K=exp(-kappa*k/2)#
	K#
}#
getcov<-function(xt,x,ker=kernel1,k){#
	#x is all the observed n (we use 2m here) locations and xt is the new pair#
	x=as.matrix(x)#
	xt=as.matrix(xt)#
	n=nrow(x)#
	m=nrow(xt)#
	Sigma=matrix(1,n,m)#
	for (i in 1:n){#
		for (j in 1:m){#
			Sigma[i,j]=ker(x[i,],xt[j,],kappa=k)#
		}#
	}#
	Sigma#
}#
gpest<-function(est_x,obs_x,obs_y,kappa){#
	est_y=t(getcov(est_x,obs_x,k=kappa))%*%solve(getcov(obs_x,obs_x,k=kappa))%*%matrix(obs_y,ncol=1)#
	est_y#
}#
#
est_x=seq(0,100,0.5)#
obs_x=seq(0,100,20)#
#
#png("GP_illustration.png")#
par(mfrow=c(2,2))#
obs_y0=rnorm(length(obs_x))*const#
for (const in c(1)){#
	for (ka in c(0.1,5,20,100)){#
		obs_y=obs_y0*const#
		est_y=gpest(est_x,obs_x,obs_y,ka)#
		plot(est_x,est_y,type='l',xlab="x",ylab="f(x)",main=sprintf("c=%.1f,kappa=%.1f",const,ka))#
		points(obs_x,obs_y)#
	}#
}#
#dev.off()
